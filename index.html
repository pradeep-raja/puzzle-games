<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Grid Quest</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background: #f4f0e6;
            text-align: center;
            margin: 0;
            padding: 0;
        }

        h1 {
            margin: 20px 0 5px;
            color: #5a3e1b;
            text-shadow: 1px 1px 2px #d9c6a5;
        }

        .toolbar {
            margin-bottom: 15px;
        }

        select,
        button {
            font-size: 16px;
            padding: 6px 10px;
            margin: 0 5px;
            border-radius: 6px;
            border: 1px solid #ccc;
            background: #fff8e1;
            cursor: pointer;
        }

        select:hover,
        button:hover {
            background: #ffe0a1;
        }

        table {
            border-spacing: 12px;
            /* bigger gap between cells */
            margin: 0 auto 15px;
        }

        td {
            width: 60px;
            height: 60px;
            background: linear-gradient(#fffbe6, #ffe9a9);
            border-radius: 10px;
            text-align: center;
            vertical-align: middle;
            font-size: 22px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.2);
            transition: transform 0.1s ease, background 0.3s;
        }

        td:hover {
            transform: scale(1.05);
            background: linear-gradient(#fff9d9, #ffd97a);
        }

        td.clicked {
            background: #fff3b0;
        }

        td.no-clue {
            background: #ffe5e5 !important;
        }

        td.hit {
            background: gold !important;
            animation: diamondFound 0.6s ease-out;
        }

        @keyframes diamondFound {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            60% {
                transform: scale(1.3);
                opacity: 1;
            }

            100% {
                transform: scale(1);
            }
        }

        .message {
            font-size: 18px;
            margin: 10px;
            padding: 8px;
            display: inline-block;
            background: #fff8dc;
            border-radius: 6px;
            box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.2);
        }

        .sparkle {
            position: absolute;
            pointer-events: none;
            animation: sparkle 1s ease-out forwards;
        }

        @keyframes sparkle {
            from {
                transform: scale(1);
                opacity: 1;
            }

            to {
                transform: scale(2);
                opacity: 0;
            }
        }
    </style>
</head>

<body>

    <h1>ðŸ’Ž Grid Quest</h1>
    <div class="toolbar">
        <label for="boardSize">Board size:</label>
        <select id="boardSize">
            <option value="5">5x5</option>
            <option value="6">6x6</option>
            <option value="7">7x7</option>
            <option value="8">8x8</option>
        </select>
        <button id="newGameBtn">New Game</button>
    </div>
    <div id="clicks">Penalty Moves: 0</div>
    <div id="message" class="message"></div>
    <div id="board"></div>

    <script>
        let N = 5;
        let candidates = new Set();
        let fixedDiamond = null;
        let penaltyMoves = 0;

        const sizeSelect = document.getElementById('boardSize');
        const newGameBtn = document.getElementById('newGameBtn');

        newGameBtn.addEventListener('click', () => {
            initGame(parseInt(sizeSelect.value, 10));
        });

        // IMPORTANT: selecting a different size triggers a fresh game immediately
        sizeSelect.addEventListener('change', (e) => {
            const size = parseInt(e.target.value, 10);
            initGame(size);
        });

        function initGame(size = 5) {
            N = size;
            // keep the dropdown in sync even if initGame is called elsewhere
            sizeSelect.value = String(N);

            penaltyMoves = 0;
            fixedDiamond = null;
            document.getElementById('clicks').textContent = `Penalty Moves: ${penaltyMoves}`;
            setMessage("Click a cell to get a distance clue!");

            buildBoard(N);

            candidates.clear();
            for (let r = 0; r < N; r++) {
                for (let c = 0; c < N; c++) {
                    candidates.add(key(r, c));
                }
            }
        }

        function buildBoard(size) {
            const table = document.createElement('table');
            for (let r = 0; r < size; r++) {
                const tr = document.createElement('tr');
                for (let c = 0; c < size; c++) {
                    const td = document.createElement('td');
                    td.dataset.r = r;
                    td.dataset.c = c;
                    td.addEventListener('click', () => onCellClick(r, c, td));
                    tr.appendChild(td);
                }
                table.appendChild(tr);
            }
            const boardDiv = document.getElementById('board');
            boardDiv.innerHTML = '';
            boardDiv.appendChild(table);
        }

        function key(r, c) { return `${r},${c}`; }
        function parseKey(k) { return k.split(',').map(Number); }
        function distance([r1, c1], [r2, c2]) {
            return Math.abs(r1 - r2) + Math.abs(c1 - c2);
        }
        function setMessage(msg) {
            document.getElementById('message').textContent = msg;
        }
        function setCellNumber(r, c, value, cls) {
            const cell = document.querySelector(`td[data-r="${r}"][data-c="${c}"]`);
            if (!cell) return;
            cell.textContent = value;
            cell.classList.remove('no-clue', 'hit', 'clicked');
            if (cls) cell.classList.add(cls);
        }

        function onCellClick(r, c, cellEl) {
            // Clear previous "no clue" icons as requested
            document.querySelectorAll('td.no-clue').forEach(td => {
                td.textContent = '';
                td.classList.remove('no-clue');
            });

            const currentCell = [r, c];

            // If diamond location known: only count penalty moves until found
            if (fixedDiamond) {
                const d = distance(currentCell, fixedDiamond);
                if (d === 0) {
                    setCellNumber(r, c, 'ðŸ’Ž', 'hit');
                    spawnSparkles(cellEl);
                    if (penaltyMoves === 0) {
                        setMessage(`ðŸ† Perfect! Found the diamond with no extra moves!`);
                    } else {
                        setMessage(`ðŸŽ‰ You found the diamond with ${penaltyMoves} penalty move${penaltyMoves > 1 ? 's' : ''}.`);
                    }
                } else {
                    penaltyMoves++;
                    document.getElementById('clicks').textContent = `Penalty Moves: ${penaltyMoves}`;
                    setCellNumber(r, c, d, 'clicked');
                }
                return;
            }

            // Before fixed: generate a feasible clue (min=3, Manhattan, exclude diagonals)
            const maxDist = maxDistanceFrom(r, c);
            const minDist = 3;
            const feasible = [];
            for (let d = minDist; d <= maxDist; d++) {
                if ([...candidates].some(k => distance(currentCell, parseKey(k)) === d)) {
                    feasible.push(d);
                }
            }

            if (feasible.length === 0) {
                // Show the not-possible icon
                setCellNumber(r, c, 'ðŸš«', 'no-clue');
                return;
            }

            const clue = feasible[Math.floor(Math.random() * feasible.length)];
            setCellNumber(r, c, clue, 'clicked');

            // Reduce candidates to those at exactly that distance
            candidates = new Set([...candidates].filter(k => distance(currentCell, parseKey(k)) === clue));

            // If exactly one remains, location is known
            if (candidates.size === 1) {
                fixedDiamond = parseKey([...candidates][0]);
                setMessage(`ðŸ’¡ The diamondâ€™s location is known! Find it with as few extra moves as possible!`);
            }
        }

        function maxDistanceFrom(r, c) {
            let max = 0;
            for (let r2 = 0; r2 < N; r2++) {
                for (let c2 = 0; c2 < N; c2++) {
                    max = Math.max(max, distance([r, c], [r2, c2]));
                }
            }
            return max;
        }

        function spawnSparkles(cellEl) {
            const rect = cellEl.getBoundingClientRect();
            for (let i = 0; i < 10; i++) {
                const s = document.createElement('div');
                s.className = 'sparkle';
                s.textContent = 'âœ¨';
                s.style.left = rect.left + Math.random() * rect.width + 'px';
                s.style.top = rect.top + Math.random() * rect.height + 'px';
                document.body.appendChild(s);
                setTimeout(() => s.remove(), 1000);
            }
        }

        // Start with whatever is selected by default
        initGame(parseInt(sizeSelect.value, 10));
    </script>

</body>

</html>